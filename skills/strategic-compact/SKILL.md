---
name: strategic-compact
description: 任意の自動コンパクトではなく、論理的な区切りで手動コンパクトを提案し、フェーズごとのコンテキストを維持する。
---

# Strategic Compact スキル

任意の自動コンパクトではなく、ワークフローの戦略的なポイントで手動 `/compact` を提案する。

## なぜ戦略的コンパクトか

自動コンパクトは任意のタイミングで発動する:
- 重要なコンテキストを失う中断が起きやすい
- 論理的なタスク境界を認識しない
- 複雑な多段作業を途中で中断する

論理的境界での戦略的コンパクト:
- **探索後、実行前** - 調査コンテキストを圧縮し、実装計画を維持する
- **マイルストーン完了後** - 次フェーズのために新鮮な状態にする
- **大きなコンテキスト切替前** - 異なるタスクの前に探索コンテキストをクリアする

## 仕組み

`suggest-compact.sh` スクリプトは PreToolUse (Edit/Write) で動作し、次を行う:

1. **ツール呼び出しの追跡** - セッション内のツール呼び出し数をカウントする
2. **しきい値検出** - 設定可能なしきい値で提案する (デフォルト: 50 回)
3. **定期リマインド** - しきい値以降は 25 回ごとに再通知する

## フック設定

`~/.claude/settings.json` に追加する:

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "tool == \"Edit\" || tool == \"Write\"",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/skills/strategic-compact/suggest-compact.sh"
      }]
    }]
  }
}
```

## 設定

環境変数:
- `COMPACT_THRESHOLD` - 最初の提案までのツール呼び出し数 (デフォルト: 50)

## ベストプラクティス

1. **計画後にコンパクト** - 計画確定後にコンパクトして新しい状態で開始する
2. **デバッグ後にコンパクト** - エラー解決のコンテキストをクリアして続行する
3. **実装途中ではコンパクトしない** - 関連する変更のコンテキストを保つ
4. **提案を読む** - フックは *いつ* を伝え、*するか* は自分で決める

## 関連

- [The Longform Guide](https://x.com/affaanmustafa/status/2014040193557471352) - トークン最適化セクション
- Memory persistence hooks - コンパクト後も残る状態向け
